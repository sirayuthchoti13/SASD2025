# Lazy Class 
## ความหมาย
***Code Smell ที่เกิดขึ้นเมื่อเรามีคลาสที่มีบทบาทน้อยเกินไป อาจจะมี Method แค่หนึ่งหรือสองอย่างที่แทบไม่ได้ทำอะไรเลย ซึ่งตามหลักการแล้ว ถ้าคลาสไหนไม่ได้ทำหน้าที่คุ้มกับความซับซ้อนที่เพิ่มขึ้นมา เราควรจะยุบหรือย้ายมันไปรวมกับส่วนอื่น***
## ตัวอย่างโค้ดที่เกิด code smell
***1. คลาส "ทางผ่าน" (The Middleman)***

***บางครั้งเราสร้างคลาสขึ้นมาเพื่อเรียกใช้ฟังก์ชันอื่นเพียงอย่างเดียว โดยที่ตัวมันเองไม่มี Logic อะไรเลย***

```python
class DiscountCalculator:
    def apply_standard_discount(self, price):
        return price * 0.9  # ลด 10% แบบดื้อๆ

class Order:
    def __init__(self, amount):
        self.amount = amount
        self.calculator = DiscountCalculator()

    def final_price(self):
        # ต้องสร้าง Object ขึ้นมาเพื่อเรียกใช้แค่บรรทัดเดียว
        return self.calculator.apply_standard_discount(self.amount)
```
***2. คลาส "เตรียมเผื่อ" (The Over-Anticipator)***

***อันนี้เจอบ่อยในโปรเจกต์ใหญ่ๆ คือคนออกแบบคิดว่า "อนาคตมันต้องซับซ้อนแน่ๆ" เลยแยกไว้ก่อน***

```python
class DatabaseConnection:
    def __init__(self, connection_string):
        self.connection_string = connection_string

    def get_string(self):
        return self.connection_string

class UserDataRepository:
    def __init__(self, db_conn: DatabaseConnection):
        self.db = db_conn

    def fetch_user_name(self):
        # แทนที่จะดึงตรงๆ ก็ต้องผ่าน DatabaseConnection ที่ไม่มีหน้าที่อื่นเลยนอกจากถือ string
        return f"User from {self.db.get_string()}"
```
***3. คลาส "ติ่ง" (The Leftover Class)***

***มักเกิดจากการ Refactor ที่ดึงความสามารถหลักออกไปไว้ที่อื่นจนตัวเองเหลือแต่โครง***

```python
class ProfilePermissions:
    # เดิมเคยมีระบบ Check Permission ยุ่งยาก 
    # แต่ตอนนี้ย้ายไปใช้ Library กลางหมดแล้ว เหลือแค่นี้...
    def can_view(self):
        return True 

class UserProfile:
    def __init__(self):
        self.perms = ProfilePermissions()
```
## ตัวอย่างโค้ดที่ Refactoring แล้ว
***วิธีแก้หลัก: Inline Class (รวมกลับเข้าไปในคลาสหลัก)***
```python
class User:
    def __init__(self, name, age):
        self.name = name  # เก็บ name ไว้ที่นี่เลย ไม่ต้องแยกคลาส
        self.age = age

    def show_info(self):
        print(f"Name: {self.name}, Age: {self.age}")
```
***ตัวอย่าง (Java) ก่อน Refactor***
```python
class Address {
    private String city;

    public String getCity() {
        return city;
    }
}

class Customer {
    private Address address;

    public String getCity() {
        return address.getCity();
    }
}
```
***หลัง Refactor***
```python
class Customer {
    private String city;

    public String getCity() {
        return city;
    }
}
```
## กรณีที่ Lazy Class ไม่ใช่ปัญหา (ไม่จำเป็นต้อง Refactor)
***กรณีที่ 1: เตรียมรองรับการขยายในอนาคต***
```python
class PaymentProcessor:
    def process(self, amount):
        print("Processing payment...")
```
***ตอนนี้อาจดูเล็ก แต่ในอนาคตอาจเพิ่ม:***

* Credit Card
* QR Code
* Crypto

***กรณีที่ 2: ใช้เพื่อแยก Responsibility (SRP) ตามหลัก Single Responsibility Principle***
```python
class Logger:
    def log(self, msg):
        print(msg)
```
* แม้จะเล็กแต่แยกหน้าที่ชัดเจน → ดีต่อการดูแล

***กรณีที่ 3: ใช้กับ Framework / Architecture เช่น MVC / Clean Architecture***
```python
class UserDTO:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```
**DTO อาจไม่มี logic แต่จำเป็นสำหรับ:**
* ส่งข้อมูล
* Mapping
* API
  
ไม่ควรลบ

***กรณีที่ 4: เพื่อความเข้าใจของระบบ (Readability)***
```python
class Email:
    def __init__(self, value):
        self.value = value
```
* แม้เล็ก แต่ช่วยให้โค้ดอ่านแล้วเข้าใจว่าเป็น "Email"
```python
send(Email("abc@gmail.com"))  # ชัดเจนกว่า
send("abc@gmail.com")
```

<img width="1500" height="900" alt="lazy-class-01-3x" src="https://github.com/user-attachments/assets/4baa950a-c3b9-4f97-b101-752a3b6bbb44" />

